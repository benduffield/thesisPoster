library(rstan)
library(cmdstanr)
library(bayesplot)
library(plyr)
library(posterior)
library(fields)
library(reticulate)
#-----------------------------------------
#Creating model
#-----------------------------------------

playground_model = cmdstan_model(stan_file = "GP_periodic_time.stan")

Vspt_obs = Vspt
Vrv_obs = Vrv
Vlv_obs = Vlv
tsteps_obs = tsteps

mydata = list(
  N = length(Vspt_obs),
  x1 = Vrv_obs,
  x2 = Vlv_obs,
  x3 = tsteps_obs,
  y = Vspt_obs
)

#-----------------------------------------
#MAP estimates for parameters (using 30 points generated by NR in 0-0.75 second range)
#-----------------------------------------

MAP_params = playground_model$optimize(data = mydata, jacobian = TRUE)

MAP_params$summary()

sigma_MAP = as.double(MAP_params$summary("sigma")[2])

length_scale1_MAP = as.double(MAP_params$summary("length_scale1")[2])

length_scale2_MAP = as.double(MAP_params$summary("length_scale2")[2])

length_scale3_MAP = as.double(MAP_params$summary("length_scale3")[2])

period_MAP = 0.75

tau_sq_MAP = 1e-7

param_samples = playground_model$sample(data = mydata,
                                        chains = 3,
                                        parallel_chains = 3,
                                        iter_warmup = 1000,
                                        iter_sampling = 1000)

mcmc_trace(param_samples$draws(),pars = c("sigma", "length_scale1", "length_scale2","length_scale3"))
param_samples
param_samples$draws()
mcmc_hist(param_samples$draws())

#-----------------------------------------
#Setting up mean and covariance for prediction
#-----------------------------------------

Cov_QP <- function(x1, x1p, x2, x2p, x3, x3p, sigma = sigma_MAP, length_scale1 = length_scale1_MAP,
                       length_scale2 = length_scale2_MAP, length_scale3 = length_scale3_MAP, length_scale4 = length_scale4_MAP,
                       period = period_MAP){
  res = sigma^2 * 
    (exp(-((outer(x1, x1p, "-"))^2)/(2*(length_scale1)^2)) * 
    exp(-((outer(x2, x2p, "-"))^2)/(2*(length_scale2)^2)) * 
    exp(-2/(length_scale3)^2 * (sin(pi * abs(outer(x3, x3p, "-"))/period))^2))
  return(res)
}


pred_mean_QP <- function(x1_pred, x1_obs, x2_pred, x2_obs, x3_pred, x3_obs, y, nugget = tau_sq_MAP){
  C_xX <- Cov_QP(x1_pred, x1_obs, x2_pred, x2_obs, x3_pred, x3_obs)
  C_XX <- Cov_QP(x1_obs, x1_obs, x2_obs, x2_obs, x3_obs, x3_obs)
  m <-C_xX %*% solve(C_XX + (nugget*diag(ncol(C_XX)))) %*% y
  return(m)
}

pred_cov_QP <- function(x1_pred, x1_obs, x2_pred, x2_obs, x3_pred, x3_obs, nugget = tau_sq_MAP){
  C_xX <- Cov_QP(x1_pred, x1_obs, x2_pred, x2_obs, x3_pred, x3_obs)
  C_XX <- Cov_QP(x1_obs, x1_obs, x2_obs, x2_obs, x3_obs, x3_obs)
  s <- Cov_QP(x1_pred, x1_pred, x2_pred, x2_pred, x3_pred, x3_pred) - C_xX %*% solve(C_XX + (nugget*diag(ncol(C_XX)))) %*% t(C_xX)
  return(s)
}

#-----------------------------------------
#Predicted values (evaluate NR at 1000 points in 0-10 second range)
#-----------------------------------------

Vrv_pred = Vrv
Vlv_pred = Vlv
time_pred = tsteps

Pred_df = matrix(nrow = length(Vrv_pred), ncol = 4)

Pred_df[,1] = pred_mean_QP(Vrv_pred, Vrv_obs, Vlv_pred, Vlv_obs, time_pred, tsteps_obs, Vspt_obs)
Pred_df[,2] = diag(pred_cov_QP(Vrv_pred, Vrv_obs, Vlv_pred, Vlv_obs, time_pred, tsteps_obs))
Pred_df[,3] = Pred_df[,1] + (1.997 * sqrt(Pred_df[,2]))
Pred_df[,4] = Pred_df[,1] - (1.997 * sqrt(Pred_df[,2]))

QP_plot = ggplot() + 
  geom_line(aes(x = time_pred, y = Pred_df[,1]), col = "#007d69", lwd = 0.8) + 
  geom_point(aes(x = tsteps_obs, y = Vspt_obs), col = "#003c3c") +
  geom_ribbon(aes(x = tsteps, ymin = Pred_df[,4], ymax = Pred_df[,3]), fill = "red", alpha = 0.3) + 
  labs(title = "Mean of posterior GP using QP kernel",
       x = "Time (s)",
       y = "Vspt")

QP_plot
  
